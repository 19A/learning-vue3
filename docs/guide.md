# 起步准备

这一章是为刚刚迈入前端工程化、或者还没有接触过前端工程化的同学准备的。

如果你刚从传统的用 HTML + CSS + JS 手写页面的认知阶段走过来，这一章的内容对你下阶段的学习应该很有用。

在这里会介绍一些前置的知识点科普，方便开始学习 Vue3 的时候，不会对一些基本的认知和操作存在太多疑惑。

:::tip
本指南需要具备一定的 HTML 、 CSS 和 JavaScript 基础，如果完全不懂，请先对这三个知识点进行一些入门的学习。
:::

## 了解前端工程化

现在在前端的工作中，实际业务里的的前端开发，和你刚接触的前端开发已经完全不同了。

刚接触前端的时候，做一个页面，是先创建 HTML 页面文件写写页面结构，在里面写 CSS 代码美化页面，再根据需要写一些 JavaScript 代码增加交互功能，需要几个页面就创建几个页面，相信大家的前端起步都是从这个模式开始的。

而实际上的前端开发工作，早已进入了前端工程化开发的时代，已经充满了各种现代化框架、预处理器、代码编译…

最终的产物也不再单纯是多个 HTML 页面，经常能看到 SPA / SSR / SSG 等词汇的身影。

### 传统开发的弊端

在了解什么是前端工程化之前，我们先回顾一下传统开发存在的弊端，这样更能知道我们为什么需要它。

在传统的前端开发模式下，前端工程师是在 HTML 文件里直接编写代码，所需要的 JavaScript 代码是通过 `script` 标签以内联或者文件引用的形式放到 HTML 代码里的。

例如这样：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>

  <!-- 引入 JS 文件 -->
  <script src="./js/lib-1.js"></script>
  <script src="./js/lib-2.js"></script>
  <!-- 引入 JS 文件 -->
  
</body>
</html>
```

如演示代码，虽然可以把代码分成多个文件来维护，这样可以有效降低代码维护成本，但在实际开发过程中，还是会存在代码运行时的一些问题。

#### 一个案例

我们继续用上面的演示代码，来看一个最简单的一个例子。

先在 `lib-1.js` 文件里，我们声明一个变量：

```js
var foo = 1
```

然后在 `lib-2.js` 文件里，我们也声明一个变量（没错，也是 `foo` ）：

```js
var foo = 2
```

然后在 HTML 代码里追加一个 `script` ，打印这个值：

```html{16-20}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>

  <!-- 引入 JS 文件 -->
  <script src="./js/lib-1.js"></script>
  <script src="./js/lib-2.js"></script>
  <!-- 引入 JS 文件 -->

  <!-- 假设这里是实际的业务代码 -->
  <script>
    console.log(foo)
  </script>
  <!-- 假设这里是实际的业务代码 -->
  
</body>
</html>
```

你猜会输出什么？ —— 答案是 `2` 。

如果你不知道 `lib-2.js` 里也声明了一个 `foo` 变量，如果在后面的代码里预期了 `foo + 2 === 3` ，那么这样就得不到你想要的结果（因为 `lib-1.js` 里的 `foo` 是 `1` ，  `1 + 2` 等于 `3` ） 。

原因是 JavaScript 的加载顺序是从上到下，当使用 `var` 声明变量时，如果命名有重复，那么后加载的变量会覆盖掉先加载的变量。

这是使用 `var` 声明的情况，它允许使用相同的名称来重复声明，那么换成 `let` 或者 `const` 呢？

虽然不会出现重复声明的情况，但你会收获一段报错：

```bash
Uncaught SyntaxError: Identifier 'foo' has already been declared (at lib-2.js:1:1)
```

你的程序这次直接崩溃了，因为 `let` 和 `const` 无法重复声明，从而抛出这个错误，程序依然无法正确运行。

#### 更多问题

以上只是一个最简单的案例，就暴露出了传统开发很大的弊端，然而并不止于此，实际上，存在了诸如以下这些的问题：

1. 如本案例，可能存在同名的变量声明，引起变量冲突
2. 引入多个资源文件时，比如有多个 JS 文件，在其中一个 JS 文件里面使用了在别处声明的变量，无法快速找到是在哪里声明的，大型项目难以维护
3. 类似第 1 、 2 点提到的问题无法轻松预先感知，很依赖开发人员人工定位原因
4. 大部分代码缺乏分割，比如一个工具函数库，很多时候需要整包引入到 HTML 里，文件很大，然而实际上只需要用到其中一两个方法
5. 由第 3 点大文件延伸出的问题， `script` 的加载从上到下，容易阻塞页面渲染
6. 不同页面的资源引用都需要手动管理，容易造成依赖混乱，难以维护
7. 如果你要压缩 CSS 、混淆 JS 代码，也是要人工使用工具去处理后替换，容易出错

当然，实际上还会有更多的问题会遇到。

### 工程化带来的优势

为了解决传统开发的弊端，前端也开始引入工程化开发的概念，借助工具来解决人工层面的繁琐事情。

1. 引入了模块化和包的概念，作用域隔离，解决了代码冲突的问题
2. 按需导出和导入机制，让编码过程更容易定位问题
3. 自动化的代码检测流程，有问题的代码在开发过程中就可以被发现
4. 编译打包机制可以让你使用开发效率更高的编码方式，比如 Vue 组件、 CSS 的各种预处理器
5. 引入了代码兼容处理的方案（ e.g. Babel ），可以让你自由使用更先进的 JavaScript 语句，而无需顾忌浏览器兼容性，因为最终会帮你转换为浏览器兼容的实现版本
6. 引入了 Tree Shaking 机制，清理没有用到的代码，减少项目构建后的体积

还有非常多的体验提升！列举不完！而对应的工具，根据用途也会有非常多的选择。

### 如何实践工程化

基于 Vue 3 的项目，最主流的工程化组合拳有以下两种：

常用方案|Runtime|构建工具|框架
:-:|:-:|:-:|:-:
方案一|Node|Webpack|Vue
方案二|Node|Vite|Vue

当你技术成熟的时候，还可以选择更喜欢的方案自行组合，例如用 Deno 来代替 Node ，但前期我们还是按照主流的方案来进入工程化的学习。

下面的内容我们将根据 Vue 3 的工程化开发，逐一讲解涉及到常用的工具，了解它们的用途和用法。

## 命令行工具

在工程化开发过程中，前端开发已离不开各种命令行操作，请先准备好命令行工具。

### Windows

Windows 可以使用自带的 CMD 或者 Windows PowerShell 工具。

但为了更好的开发体验，推荐使用以下工具（需要下载安装），可以根据自己的喜好选择其一：

名称|简介|下载
:-:|:--|:-:
Windows Terminal|由微软推出的强大且高效的 Windows 终端|[前往 GitHub 下载](https://github.com/microsoft/terminal)
CMDer|一款体验非常好的 Windows 控制台模拟器|[前往 GitHub 下载](https://github.com/cmderdev/cmder)

我现在在我的 Windows 台式机上是使用 Windows Terminal 比较多，在此之前是用 CMDer ，两者的设计和体验都非常优秀，当然，还有颜值。

### macOS

如果使用的是 Mac 系统，可以直接使用系统自带的 “终端” 工具，我在我的 Macbook 上是使用自带的终端进行开发。

:::tip
其实只要能正常使用命令行，对于前端工程师来说就可以满足日常需求，但选择更喜欢的工具，可以让自己的开发过程更为身心愉悦！
:::

## 了解 Node.js

只要你在近几年有接触过前端开发，哪怕你没有实际使用过，也应该有听说过 Node.js ，那么它是一个什么样的存在？

### 什么是 Node.js

Node.js （简称 Node ） 是一个基于 Chrome V8 引擎构建的 JS 运行时（ JavaScript Runtime ）。

它让 JavaScript 代码不再局限于网页上，还可以跑在客户端、服务端等场景，极大的推动了前端开发的发展，现代的前端开发几乎都离不开 Node 。

### 什么是 Runtime

Runtime ，可以叫它 “运行时” 或者 “运行时环境” ，这个概念是指，你的代码在哪里运行，哪里就是运行时。

传统的 JavaScript 只能跑在浏览器上，每个浏览器都为 JS 提供了一个运行时环境，你可以简单的把浏览器当成一个 Runtime ，明白了这一点，相信你就能明白什么是 Node 。

Node 就是一个让 JS 可以脱离浏览器运行的环境，当然，这里并不是说 Node 就是浏览器。

### Node 和浏览器的区别

虽然 Node 也是基于 Chrome V8 引擎构建，但它并不是一个浏览器，它提供了一个完全不一样的运行时环境，没有 Window 、没有 Document 、没有 DOM 、没有 Web API ，没有 UI 界面…

但它提供了很多浏览器做不到的能力，比如和操作系统的交互，例如 “文件读写” 这样的操作在浏览器有诸多的限制，而在 Node 则轻轻松松。

对于前端开发者来说， Node 的巨大优势在于，使用一种语言就可以编写所有东西（前端和后端），不再花费很多精力去学习各种各样的开发语言。

哪怕你仅仅只做 Web 开发，也不再需要顾虑新的语言特性在浏览器上的兼容性（ e.g. ES6 、 ES7 、 ES8 、 ES9 …）， Node 配合构建工具，以及诸如 Babel 这样的代码编译器，可以帮你转换为浏览器兼容性最高的 ES5 。

当然还有很多工程化方面的好处，总之一句话，使用 Node ，你的开发体验会非常好。

### 下载和安装 Node

在 Node.js 官网提供了安装包的下载，不论你是使用 Windows 系统还是 MacOS 系统， Node 都提供了对应的安装包，直接下载安装包并运行即可安装到你的电脑里，就可以用来开发你的项目了。

点击访问：[Node.js 官网下载](https://nodejs.org/zh-cn/download/)

安装后，打开你的 [命令行工具](#命令行工具) ，输入以下命令即可查看是否安装成功：

```bash
node -v
```

如果已成功安装，会在控制台输出当前的 Node 版本号。

### 版本之间的区别

你可以看到官网标注了 LTS 和 Current 两个系列，并且对应了不同的版本号。

LTS ，全称 Long Time Support ，长期维护版本，这个系列代表着稳定，建议首次下载以及后续的每次升级都选择 LTS 版本，减少开发过程中的未知问题出现，大版本号都是偶数（ e.g. v16.x.x ）。

Current 是最新发布版本，或者叫 “尝鲜版” ，你可以在这个系列体验到最新的功能，但也可能会有一些意想不到的问题和兼容性要处理，大版本号都是奇数（ e.g. v17.x.x ）。

不论是 LTS 还是 Current ，每个系列下面都还有不同的大版本和小版本，是不是每次都必须及时更新到最新版呢？

当然不是，你完全可以依照你的项目技术栈依赖的最低 Node 版本去决定是否需要升级，不过如果条件允许，还是建议至少要把大版本升级到最新的 LTS 版本。

### 配置环境变量

>待完善

### 配置镜像源

>待完善

## 了解 Node 项目

>待完善

### 初始化一个项目

>待完善

### 了解 package.json

>待完善

### 基础的项目结构

>待完善

### Hello Node

>待完善

## 了解模块化设计

读到这里，你应该已经了解 Node 了，可能你也已经安装好了它，但在开始使用之前，你还需要了解一些概念。

在未来的日子里（不限于本教程，与你在前端工程化相关的工作内容息息相关），你会频繁的接触到两个词：模块（ Module ）和包（ Package ）。

模块和包是 Node 开发最重要的组成部分，不管你是全部自己实现一个项目，还是会依赖各种第三方轮子来协助你的开发，项目的构成都离不开这两者。

### 传统开发的问题

>待完善

### 解决了什么问题

在软件工程的设计原则里，有一个原则叫 “单一职责” 。

假设一个代码块负责了多个职责的功能支持，在后续的迭代过程中，维护成本会极大的增加，虽然只需要修改这个代码块，但需要兼顾职责 1 、职责 2 、职责 3 … 等多个职责的兼容性，稍不注意就会引起工程运行的崩溃。

“单一职责” 的目的就是减少功能维护带来的风险，把代码块的职责单一化，让代码的可维护性更高。

一个完整业务的内部实现，不应该把各种代码都耦合在一起，而应该按照职责去划分好代码块，再进行组合，形成一个 “高内聚，低耦合” 的工程设计。

模块化就是由此而来，在前端工程里，每个单一职责的代码块，就叫做模块（ Module ） ，模块有自己的作用域，功能与业务解耦，非常方便复用和移植。

### 如何实现模块化

在前端工程的发展过程中，不同时期诞生了很多不同的模块化机制，例如 CommonJS （ CJS ）  、 AMD 、CMD 、 UMD 和 ES Module （ ESM ） 。

其中 AMD 、CMD 、 UMD 都是上一个时代用于浏览器端的 JS 模块化方案，新的业务不太会主动使用了，可以在后续有接触的时候再了解。

ES Module 是 JavaScript 在 ES6（ ECMAScript 2015 ）版本推出的模块化标准，旨在成为浏览器和服务端通用的模块解决方案。

CommonJS 原本是服务端的模块化标准（设计之初也叫 ServerJS ），是为 JavaScript 设计的用于浏览器之外的一个模块化方案， Node 默认支持了该规范，在 Node 12 之前也只支持 CJS ，但从 Node 12 开始，已经同时支持 ES Module 的使用。

至此，不论是 Node 端还是浏览器端， ES Module 是统一的模块化标准了！

但由于历史原因， CJS 在 Node 端依然是非常主流的模块化写法，所以还是值得进行了解，因此下面的内容将主要介绍 CJS 和 ESM 这两种模块化规范是如何实际运用。

### 准备工作

在开始体验模块化的编写之前，你需要先 [安装好 Node](#下载和安装-node) 在你的电脑里，然后打开 [命令行工具](#命令行工具) ， `cd` 到你平时管理项目的目录路径。

创建 Node 项目有多种方式，这里我们通过 [Create Preset](https://github.com/awesome-starter/create-preset) 来拉取一个基础的 Node 模板。

```bash
npm create preset init
```

根据命令行的提示操作：

1. 输入项目名称（我们这里起名 `node-demo` ）

2. 选择 `node` 技术栈，再选择 `node-basic` 模板，回车后即可创建一个 Node 项目

3. 根据控制台的提示，输入 `cd node-demo` 切到项目目录下，输入 `npm run dev` 运行程序

可以看到控制台输出：

```bash
npm run dev

> node-demo@0.0.0 dev
> node src/index.js

Hello World!
```

说明项目安装成功并能够正常运行了。

### 用 CommonJS 设计模块

虽然现在推荐使用 ES Module 作为模块化标准，但是日后你在工作的过程中，还是不免会遇到要维护一些老项目，因此了解 CommonJS 还是非常有必要的。

以下简称 CJS 代指 CommonJS 规范。

#### 基本语法

CJS 使用 `module.exports` 或者 `exports` 语法导出模块，使用 `require` 导入模块。

#### 默认导出

你可以使用 `module.exports` 或者 `exports` （不推荐）语法导出模块：

```js

```

#### 默认导入

>待完善

#### 命名导出

>待完善

#### 命名导入

>待完善

#### 导入时重命名

>待完善

### 用 ES Module 设计模块

>待完善

#### 基本语法

>待完善

#### 默认导出

>待完善

#### 默认导入

>待完善

#### 命名导出

>待完善

#### 命名导入

>待完善

#### 导入时重命名

>待完善

## 了解组件化设计

>待完善

### 什么是组件化

>待完善

### 解决了什么问题

>待完善

### 如何实现组件化

>待完善

## 了解包和插件

>待完善

### 什么是包

>待完善

### 什么是包管理器

>待完善

### 包的安装和使用

>待完善

#### 本地安装

>待完善

#### 全局安装

>待完善

## 了解构建工具

>待完善

### Webpack

>待完善

### Vite

>待完善

### 开发环境和生产环境

>待完善

## 了解 Vue.js

>待完善

### 了解渐进式框架

>待完善

### 了解单页面应用

>待完善

### 传统页面与单组件文件

>待完善

### 事件驱动与数据驱动

>待完善

#### 事件驱动

>待完善

#### 数据驱动

>待完善

### 真实 DOM 与虚拟 DOM

>待完善

#### 真实 DOM

>待完善

#### 虚拟 DOM

>待完善

### 了解响应式数据

>待完善

### Vue 3 带来的变化

>待完善

### Hello Vue3

>待完善

## 了解 TypeScript

>待完善

### 为什么需要类型系统

>待完善

### 了解 tsconfig.json

>待完善

### 常用的 TS 类型定义

>待完善

#### 字符串

>待完善

#### 数值

>待完善

#### 布尔值

>待完善

#### 数组

>待完善

#### 对象（接口）

>待完善

#### 类

>待完善

#### Null

>待完善

#### Undefined

>待完善

#### 联合类型

>待完善

#### 函数

>待完善

#### 任意值

>待完善

#### 第三方库

>待完善

#### 其他

>待完善

#### 类型断言

>待完善

#### 类型推论

>待完善

### 代码检查

>待完善

### 如何转换为 JavaScript

>待完善

### 如何转换为 TypeScript

>待完善

### Hello TypeScript

>待完善

## 本章结语

>待完善

<!-- 谷歌广告 -->
<ClientOnly>
  <google-adsense />
</ClientOnly>
<!-- 谷歌广告 -->

<!-- 评论 -->
<ClientOnly>
  <gitalk-comment
    :issueId="45"
  />
</ClientOnly>
<!-- 评论 -->
